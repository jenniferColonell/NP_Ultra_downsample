function callDownsampling

% for a list of input binary files, call poolChan with a specified 
% downsampled pattern type, and a 'noiseModel', which is just the 
% channel map and fourier transform of noise data for a UHD probe.

% combining data across channels is a point by point calculation, so each
% block of data is analyzed independently (no overlap).

% Sites are combined by averaging the signal across sites. This reduces the
% amplifier and thermal noise by 1/sqrt(N sites). To simulate data with full
% amplifier noise, we add noise with the same frequency spectrum as a self 
% referencedd noise test in PBS. This data is stored in a 'noise model'
% structure generated by 'make_noise_model.m'.

% full path to noise model
nmPath = 'C:\Users\labadmin\Documents\jic\np_downsample\UHD_extref_noiseModel.mat';
noiseModel = load(nmPath);       % loads structure nm
addNoise = 1;                    % set to 1 to add noise

% new pattern type
newPatType = 4;

% SGLX data -- if true, will extract basename to create output and chanMap names
sglxData = 1;

fileList{1} = 'C:\Users\labadmin\Documents\jic\np_downsample\SC039_071020_2min_g0_tcat.imec0.ap.bin';

nFile = numel(fileList);

NT = 100*30000;  % number of time points per batch
orig_NchanTOT = 385;

for i = 1:nFile

    currFile = fileList{1};
    [currPath,currName,~] = fileparts(currFile);

    if sglxData
        baseName = extractBefore(currName,'_g');
        gt_decor = sprintf('_g%s', extractAfter(currName,'_g'));
        outBinName = sprintf( '%s_pat%d%s.bin', baseName,newPatType,gt_decor );
        outChanMapName = sprintf( '%s_pat%d_chanMap.mat', baseName,newPatType );
        inputMetaName = sprintf('%s.meta', currName);
        outMetaName = sprintf( '%s_pat%d%s.meta', baseName,newPatType,gt_decor );
    else
        outBinName = sprintf('pat%d_out%d.bin', newPatType,i);
        outChanMapName = sprintf( '%pat%d_out%d_chanMap.mat', newPatType,i );
    end

    bytes       = get_file_size(fileList{i}); % size in bytes of raw binary
    nTimepoints = floor(bytes/orig_NchanTOT/2); % number of total timepoints
    Nbatch      = ceil(nTimepoints /NT); % number of data batches

    fid         = fopen(fileList{1}, 'r'); % open for reading raw data
    fidW        = fopen(fullfile(currPath,outBinName), 'w'); % open for writing processed data

    for ibatch = 1:Nbatch-1
        offset = 2*NT*(ibatch -1)*orig_NchanTOT;
        fseek(fid, offset, 'bof'); % fseek to batch start in raw file
        buff = fread(fid, [orig_NchanTOT NT], '*int16'); % read and reshape.
        if newPatType > 0
            [buff, chanMap, xCoord, yCoord] = poolChan(buff, addNoise, noiseModel, newPatType);
        end
        fwrite(fidW, buff, 'int16'); % write this batch to binary file
    end

    % last batch
    offset = 2*NT*(Nbatch-1)*orig_NchanTOT;
    fseek(fid, offset, 'bof'); % fseek to batch start in raw file
    NTlast = nTimepoints - NT*(Nbatch-1);
    buff = fread(fid, [orig_NchanTOT NTlast], '*int16'); % read and reshape.
    if newPatType > 0
        [buff, chanMap, xCoord, yCoord] = poolChan(buff, addNoise, noiseModel, newPatType);
    end
    fwrite(fidW, buff, 'int16'); % write this batch to binary file

    fclose(fid);
    fclose(fidW);
    if newPatType > 0
        % write a ks2 channel map for the new file
        NchanTOT = numel(chanMap);
        chanMap = 1:NchanTOT;
        chanMap0ind = chanMap -1;
        connected = ones([NchanTOT,1]);
        kcoords = ones([NchanTOT,1]);
        save(fullfile(currPath,outChanMapName), 'NchanTOT','chanMap','chanMap0ind', 'xCoord','yCoord','connected','kcoords')
    else
        NchanTOT = orig_NchanTOT;   
    end

    if sglxData
        % make a metadata file
        
        fp = dir(fullfile(currPath,outBinName));        
        newTag = cell(4,1);
        newTag{1} = sprintf('%s%d', 'fileSizeBytes=', fp.bytes);
        newTag{2} = sprintf('%s%d', 'nSavedChans=', NchanTOT);
        if NchanTOT < 385
            newTag{3} = sprintf('%s%d%s', 'snsApLfSy=', NchanTOT, ',0,0');
            newTag{4} = sprintf('%s%d', 'snsSaveChanSubset=0:',NchanTOT-1);
        else
            newTag{3} = sprintf('%s', 'snsApLfSy=384,0,1');
            newTag{4} = sprintf('%s', 'snsSaveChanSubset=0:383,768');
        end
        repTags = cell(4,1);
        repTags{1} = 'fileSizeBytes';
        repTags{2} = 'nSavedChans';
        repTags{3} = 'snsApLfSy';
        repTags{4} = 'snsSaveChanSubset';
        
        fmodel = fopen( fullfile(currPath,inputMetaName), 'r');
        fmeta = fopen( fullfile(currPath,outMetaName), 'w');
        
        tline = fgetl(fmodel);
        while ischar(tline)
            currTag = extractBefore(tline,'=');
            tagFound = find(strcmp(repTags, currTag));
            if isempty(tagFound)
                %copy over this line as is
                fprintf(fmeta, '%s\n', tline );
            else
                fprintf('found: %s\n', repTags{tagFound} );
                fprintf(fmeta, '%s\n', newTag{tagFound} );
            end  
            tline = fgetl(fmodel);
        end
        fclose(fmeta);
        fclose(fmodel);

    end
end



end



function bytes = get_file_size(fname)
% gets file size in bytes, ensuring that symlinks are dereferenced
% MP: not sure who wrote this code, but they were careful to do it right on Linux
    bytes = NaN;
    if isunix
        cmd = sprintf('stat -Lc %%s %s', fname);
        [status, r] = system(cmd);
        if status == 0
            bytes = str2double(r);
        end
    end

    if isnan(bytes)
        o = dir(fname);
        bytes = o.bytes;
    end
end