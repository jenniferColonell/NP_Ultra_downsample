function callDownsampling

% for a list of input binary files, call poolChan with a specified 
% downsampled pattern type, and a 'noiseModel', which is just the 
% channel map and fourier transform of noise data for a UHD probe.

% combining data across channels is a point by point calculation, so each
% block of data is analyzed independently (no overlap).

% Sites are combined by averaging the signal across sites. This reduces the
% amplifier and thermal noise by 1/sqrt(N sites). To simulate data with full
% amplifier noise, we add noise with the same frequency spectrum as a self 
% referencedd noise test in PBS. This data is stored in a 'noise model'
% structure generated by 'make_noise_model.m'.

% full path to noise model
nmPath = 'E:\MEArec_for_localization\UHD512_100U\UHD512_sim_noiseModel.mat';
noiseModel = load(nmPath);       % loads structure nm
addNoise = 1;                    % set to 1 to add noise

% new pattern type
newPatType = 4;

% SGLX data -- if true, will extract basename to create output and chanMap names
sglxData = 1;

%fileList{1} = 'C:\Users\labadmin\Documents\jic\np_downsample\test_data\SC039_071020_2min_g0_tcat.imec0.ap.bin';
fileList{1} = 'E:\MEArec_for_localization\UHD512_100U\UHD512_100U_10uV_g0_t0.imec0.ap.bin';
nFile = numel(fileList);

NT = 100*30000;  % number of time points per batch


for i = 1:nFile

    currFile = fileList{1};
    [currPath,currName,~] = fileparts(currFile)

    if sglxData
        baseName = extractBefore(currName,'_g');
        gt_decor = sprintf('_g%s', extractAfter(currName,'_g'));
        outBinName = sprintf( '%s_pat%d%s.bin', baseName,newPatType,gt_decor );
        outChanMapName = sprintf( '%s_pat%d_chanMap.mat', baseName,newPatType );
        inputMetaName = sprintf('%s.meta', currName);
        outMetaName = sprintf( '%s_pat%d%s.meta', baseName,newPatType,gt_decor );

        [meta] = ReadMeta(inputMetaName, currPath);
        rm_order = parseShankMap(meta);
        [AP,LF,SY] = ChannelCountsIM(meta);
        orig_NchanTOT = AP + SY;

    else
        outBinName = sprintf('pat%d_out%d.bin', newPatType,i);
        outChanMapName = sprintf( '%pat%d_out%d_chanMap.mat', newPatType,i );
        % assume default UHD configuration in binary
        orig_NchanTOT = 385;
        rm_order = 1:384;
    end

    need_reorder = issorted(rm_order);

    bytes       = get_file_size(fileList{i}); % size in bytes of raw binary
    nTimepoints = floor(bytes/orig_NchanTOT/2); % number of total timepoints
    Nbatch      = ceil(nTimepoints /NT); % number of data batches

    fid         = fopen(fileList{1}, 'r'); % open for reading raw data
    fidW        = fopen(fullfile(currPath,outBinName), 'w'); % open for writing processed data

    for ibatch = 1:Nbatch-1
        offset = 2*NT*(ibatch -1)*orig_NchanTOT;
        fseek(fid, offset, 'bof'); % fseek to batch start in raw file
        buff = fread(fid, [orig_NchanTOT NT], '*int16'); % read and reshape.
        if need_reorder
            buff = buff(rm_order,:);
        end
        if newPatType > 0
            [buff, chanMap, xCoord, yCoord] = poolChan(buff, addNoise, noiseModel, newPatType);
        end
        fwrite(fidW, buff, 'int16'); % write this batch to binary file
    end

    % last batch
    offset = 2*NT*(Nbatch-1)*orig_NchanTOT;
    fseek(fid, offset, 'bof'); % fseek to batch start in raw file
    NTlast = nTimepoints - NT*(Nbatch-1);
    buff = fread(fid, [orig_NchanTOT NTlast], '*int16'); % read and reshape.
    if newPatType > 0
        [buff, chanMap, xCoord, yCoord, saveChanStr, newShankMap] = poolChan(buff, addNoise, noiseModel, newPatType);
    end
    fwrite(fidW, buff, 'int16'); % write this batch to binary file

    fclose(fid);
    fclose(fidW);
    if newPatType > 0
        % write a ks2 channel map for the new file
        NchanTOT = numel(chanMap);
        chanMap = 1:NchanTOT;
        chanMap0ind = chanMap -1;
        connected = ones([NchanTOT,1]);
        kcoords = ones([NchanTOT,1]);
        save(fullfile(currPath,outChanMapName), 'NchanTOT','chanMap','chanMap0ind', 'xCoord','yCoord','connected','kcoords')
    else
        NchanTOT = orig_NchanTOT;   
    end

    if sglxData
        % make a metadata file
        
        fp = dir(fullfile(currPath,outBinName));        
        newTag = cell(5,1);
        newTag{1} = sprintf('%s%d', 'fileSizeBytes=', fp.bytes);
        newTag{2} = sprintf('%s%d', 'nSavedChans=', NchanTOT);
        newTag{3} = sprintf('%s%d%s', 'snsApLfSy=', NchanTOT, ',0,0');
        newTag{4} = sprintf('%s', saveChanStr);
        newTag{5} = sprintf('%s%s', 'snsShankMap=', newShankMap);

        repTags = cell(5,1);
        repTags{1} = 'fileSizeBytes';
        repTags{2} = 'nSavedChans';
        repTags{3} = 'snsApLfSy';
        repTags{4} = 'snsSaveChanSubset';
        repTags{5} = '~snsShankMap';
        
        fmodel = fopen( fullfile(currPath,inputMetaName), 'r');
        fmeta = fopen( fullfile(currPath,outMetaName), 'w');
        
        tline = fgetl(fmodel);
        while ischar(tline)
            currTag = extractBefore(tline,'=');
            tagFound = find(strcmp(repTags, currTag));
            if isempty(tagFound)
                %copy over this line as is
                fprintf(fmeta, '%s\n', tline );
            else
                fprintf('found: %s\n', repTags{tagFound} );
                fprintf(fmeta, '%s\n', newTag{tagFound} );
            end  
            tline = fgetl(fmodel);
        end
        fclose(fmeta);
        fclose(fmodel);

    end
end



end



function bytes = get_file_size(fname)
% gets file size in bytes, ensuring that symlinks are dereferenced
% MP: not sure who wrote this code, but they were careful to do it right on Linux
    bytes = NaN;
    if isunix
        cmd = sprintf('stat -Lc %%s %s', fname);
        [status, r] = system(cmd);
        if status == 0
            bytes = str2double(r);
        end
    end

    if isnan(bytes)
        o = dir(fname);
        bytes = o.bytes;
    end
end


function [meta] = ReadMeta(metaName, path)

    % Parse ini file into cell entries C{1}{i} = C{2}{i}    
    fid = fopen(fullfile(path, metaName), 'r');
% -------------------------------------------------------------
%    Need 'BufSize' adjustment for MATLAB earlier than 2014
%    C = textscan(fid, '%[^=] = %[^\r\n]', 'BufSize', 32768);
    C = textscan(fid, '%[^=] = %[^\r\n]');
% -------------------------------------------------------------
    fclose(fid);

    % New empty struct
    meta = struct();

    % Convert each cell entry into a struct entry
    for i = 1:length(C{1})
        tag = C{1}{i};
        if tag(1) == '~'
            % remake tag excluding first character
            tag = sprintf('%s', tag(2:end));
        end
        meta = setfield(meta, tag, C{2}{i});
    end
end % ReadMeta

function rm_order = parseShankMap( meta )
% parse shank map string to return array to map channels in row major order

    C = textscan(meta.snsShankMap, '(%d:%d:%d:%d', ...
                'EndOfLine', ')', 'HeaderLines', 1 );
    nElec = numel(C{1});
    rc_array = zeros([nElec,2]);
    rc_array(:,1) = double(cell2mat(C(3)));
    rc_array(:,2) = double(cell2mat(C(2)));
    [~,rm_order]= sortrows(rc_array);

end

function [AP,LF,SY] = ChannelCountsIM(meta)
    M = str2num(meta.snsApLfSy);
    AP = M(1);
    LF = M(2);
    SY = M(3);
end % ChannelCountsIM
